# -*- generated by 1.0.12 -*-
import da
PatternExpr_284 = da.pat.TuplePattern([da.pat.ConstantPattern('memory'), da.pat.FreePattern('p'), da.pat.FreePattern('m')])
PatternExpr_314 = da.pat.TuplePattern([da.pat.ConstantPattern('memory'), da.pat.FreePattern('p'), da.pat.FreePattern(None)])
PatternExpr_352 = da.pat.TuplePattern([da.pat.ConstantPattern('memory'), da.pat.BoundPattern('_BoundPattern355_'), da.pat.FreePattern('m')])
PatternExpr_461 = da.pat.TuplePattern([da.pat.ConstantPattern('Done')])
PatternExpr_466 = da.pat.BoundPattern('_BoundPattern467_')
PatternExpr_468 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern474_')]), da.pat.TuplePattern([da.pat.ConstantPattern('Done')])])
PatternExpr_678 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_683 = da.pat.BoundPattern('_BoundPattern684_')
PatternExpr_685 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern691_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
_config_object = {}
import sys
import time
import psutil
logfile = 'raft_da_perf.csv'

class Stat(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._StatReceivedEvent_0 = []
        self._StatReceivedEvent_1 = []
        self._StatReceivedEvent_2 = []
        self._StatReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_StatReceivedEvent_0', PatternExpr_284, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_StatReceivedEvent_1', PatternExpr_314, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_StatReceivedEvent_2', PatternExpr_352, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_StatReceivedEvent_3', PatternExpr_461, sources=[PatternExpr_466], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, algo, nservers, nclients, nrequests, maxtimeout, send_failrate, runs, **rest_700):
        super().setup(algo=algo, nservers=nservers, nclients=nclients, nrequests=nrequests, maxtimeout=maxtimeout, send_failrate=send_failrate, runs=runs, **rest_700)
        self._state.algo = algo
        self._state.nservers = nservers
        self._state.nclients = nclients
        self._state.nrequests = nrequests
        self._state.maxtimeout = maxtimeout
        self._state.send_failrate = send_failrate
        self._state.runs = runs
        pass

    def run(self):
        self.output('-------------------', self._state.algo, ': run', self._state.runs, 'started---------------------')
        module = da.import_da(self._state.algo)
        self.algorun(module)

    def start_stats(self):
        return (time.time(), psutil.cpu_times().user)

    def end_stats(self, start_time, start_time_c):
        e_time = (time.time() - start_time)
        c_time = (psutil.cpu_times().user - start_time_c)
        return (str(self._state.nservers), ((((((+ ',') + str(self._state.runs)) + ',') + str(e_time)) + ',') + str(c_time)))

    def start_module(self, servers, clients):
        self._start(servers)
        self._start(clients)

    def write_to_file(self, stats):
        f = open((('raftlogfile' + str(self._state.nservers)) + '.csv'), 'a')
        f.write(stats)
        f.close()

    def collect_memory_stats(self):
        procmem = {(p, m) for (_, _, (_ConstantPattern301_, p, m)) in self._StatReceivedEvent_0 if (_ConstantPattern301_ == 'memory')}
        procs = {p for (_, _, (_ConstantPattern330_, p, _)) in self._StatReceivedEvent_1 if (_ConstantPattern330_ == 'memory')}
        total_memory_consumed = 0
        for p in list(procs):
            memset = {m for (_, _, (_ConstantPattern368_, _BoundPattern370_, m)) in self._StatReceivedEvent_2 if (_ConstantPattern368_ == 'memory') if (_BoundPattern370_ == p)}
            mem = 0
            for m in memset:
                mem += m
            avg_mem = (mem / len(memset))
            total_memory_consumed += avg_mem
        return ((',' + str(total_memory_consumed)) + '\n')

    def algorun(self, module):
        servers = self.new(module.Server, num=self._state.nservers, send=self._state.send_failrate)
        self._setup(servers, (servers, self._state.maxtimeout))
        clients = self.new(module.Client, num=self._state.nclients)
        self._setup(clients, (list(servers), self._state.nrequests, self._state.maxtimeout))
        (start_time, start_time_c) = self.start_stats()
        self.start_module(servers, clients)
        super()._label('_st_label_452', block=False)
        c = None

        def UniversalOpExpr_453():
            nonlocal c
            for c in clients:
                if (not PatternExpr_468.match_iter(self._StatReceivedEvent_3, _BoundPattern474_=c, SELF_ID=self._id)):
                    return False
            return True
        _st_label_452 = 0
        while (_st_label_452 == 0):
            _st_label_452 += 1
            if UniversalOpExpr_453():
                _st_label_452 += 1
            else:
                super()._label('_st_label_452', block=True)
                _st_label_452 -= 1
        self.output('All clients done.')
        self.end(servers)
        stats = self.end_stats(start_time, start_time_c)
        stats += self.collect_memory_stats()
        self.write_to_file(stats)
        self.send(('done',), to=self.parent())

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_678, sources=[PatternExpr_683], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nservers = (int(sys.argv[1]) if (len(sys.argv) > 1) else 5)
        nclients = (int(sys.argv[2]) if (len(sys.argv) > 2) else 3)
        nrequests = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        maxtimeout = (int(sys.argv[4]) if (len(sys.argv) > 4) else 3000)
        send_failrate = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0.0)
        repetitions = (int(sys.argv[6]) if (len(sys.argv) > 6) else 4)
        f = open((('raftlogfile' + str(nservers)) + '.csv'), 'w')
        f.write('servers,runs,elapsed_time,cpu_time,cpu_memory(kB)\n')
        f.close()
        run = 1
        while (run <= repetitions):
            stat_proc = self.new(Stat, ('raft', nservers, nclients, nrequests, maxtimeout, send_failrate, run), num=1)
            self._start(stat_proc)
            super()._label('_st_label_669', block=False)
            p = None

            def UniversalOpExpr_670():
                nonlocal p
                for p in stat_proc:
                    if (not PatternExpr_685.match_iter(self._Node_ReceivedEvent_0, _BoundPattern691_=p)):
                        return False
                return True
            _st_label_669 = 0
            while (_st_label_669 == 0):
                _st_label_669 += 1
                if UniversalOpExpr_670():
                    _st_label_669 += 1
                else:
                    super()._label('_st_label_669', block=True)
                    _st_label_669 -= 1
            else:
                if (_st_label_669 != 2):
                    continue
            if (_st_label_669 != 2):
                break
            run += 1
            self.output('done')
