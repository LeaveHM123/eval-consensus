# -*- generated by 1.0.12 -*-
import da
PatternExpr_286 = da.pat.TuplePattern([da.pat.ConstantPattern('memory'), da.pat.FreePattern('p'), da.pat.FreePattern('m')])
PatternExpr_316 = da.pat.TuplePattern([da.pat.ConstantPattern('memory'), da.pat.FreePattern('p'), da.pat.FreePattern(None)])
PatternExpr_354 = da.pat.TuplePattern([da.pat.ConstantPattern('memory'), da.pat.BoundPattern('_BoundPattern357_'), da.pat.FreePattern('m')])
PatternExpr_480 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_485 = da.pat.BoundPattern('_BoundPattern486_')
PatternExpr_487 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern493_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_707 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_712 = da.pat.BoundPattern('_BoundPattern713_')
PatternExpr_714 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern720_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
_config_object = {}
import sys
import time
import psutil

class Stat(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._StatReceivedEvent_0 = []
        self._StatReceivedEvent_1 = []
        self._StatReceivedEvent_2 = []
        self._StatReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_StatReceivedEvent_0', PatternExpr_286, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_StatReceivedEvent_1', PatternExpr_316, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_StatReceivedEvent_2', PatternExpr_354, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_StatReceivedEvent_3', PatternExpr_480, sources=[PatternExpr_485], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, algo, nacceptors, nreplicas, nleaders, nclients, nops, runs, **rest_731):
        super().setup(algo=algo, nacceptors=nacceptors, nreplicas=nreplicas, nleaders=nleaders, nclients=nclients, nops=nops, runs=runs, **rest_731)
        self._state.algo = algo
        self._state.nacceptors = nacceptors
        self._state.nreplicas = nreplicas
        self._state.nleaders = nleaders
        self._state.nclients = nclients
        self._state.nops = nops
        self._state.runs = runs
        pass

    def run(self):
        self.output('-------------------', self._state.algo, ': run', self._state.runs, ' started---------------------')
        module = da.import_da(self._state.algo)
        self.algorun(module)

    def start_stats(self):
        return (time.time(), psutil.cpu_times().user)

    def end_stats(self, start_time, start_time_c):
        e_time = (time.time() - start_time)
        c_time = (psutil.cpu_times().user - start_time_c)
        return ((((((str(self._state.nacceptors) + ',') + str(self._state.runs)) + ',') + str(e_time)) + ',') + str(c_time))

    def start_module(self, acceptors, replicas, leaders, clients):
        self._start(acceptors)
        self._start((replicas | leaders))
        self._start(clients)

    def write_to_file(self, stats):
        f = open((('paxoslogfile' + str(self._state.nacceptors)) + '.csv'), 'a')
        f.write(stats)
        f.close()

    def collect_memory_stats(self):
        procmem = {(p, m) for (_, _, (_ConstantPattern303_, p, m)) in self._StatReceivedEvent_0 if (_ConstantPattern303_ == 'memory')}
        procs = {p for (_, _, (_ConstantPattern332_, p, _)) in self._StatReceivedEvent_1 if (_ConstantPattern332_ == 'memory')}
        total_memory_consumed = 0
        for p in list(procs):
            memset = {m for (_, _, (_ConstantPattern370_, _BoundPattern372_, m)) in self._StatReceivedEvent_2 if (_ConstantPattern370_ == 'memory') if (_BoundPattern372_ == p)}
            mem = 0
            for m in memset:
                mem += m
            avg_mem = (mem / len(memset))
            total_memory_consumed += avg_mem
        return ((',' + str(total_memory_consumed)) + '\n')

    def algorun(self, module):
        acceptors = self.new(module.Acceptor, (), num=self._state.nacceptors)
        replicas = self.new(module.Replica, num=self._state.nreplicas)
        leaders = self.new(module.Leader, (acceptors, replicas), num=self._state.nleaders)
        initial_state = []
        self._setup(replicas, (leaders, initial_state))
        clients = self.new(module.Client, (replicas, self._state.nops), num=self._state.nclients)
        (start_time, start_time_c) = self.start_stats()
        self.start_module(acceptors, replicas, leaders, clients)
        super()._label('_st_label_471', block=False)
        c = None

        def UniversalOpExpr_472():
            nonlocal c
            for c in clients:
                if (not PatternExpr_487.match_iter(self._StatReceivedEvent_3, _BoundPattern493_=c, SELF_ID=self._id)):
                    return False
            return True
        _st_label_471 = 0
        while (_st_label_471 == 0):
            _st_label_471 += 1
            if UniversalOpExpr_472():
                _st_label_471 += 1
            else:
                super()._label('_st_label_471', block=True)
                _st_label_471 -= 1
        self.output('All clients done.')
        self.send(('done',), to=((acceptors | replicas) | leaders))
        stats = self.end_stats(start_time, start_time_c)
        stats += self.collect_memory_stats()
        self.write_to_file(stats)
        self.send(('done',), to=self.parent())

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_707, sources=[PatternExpr_712], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nacceptors = (int(sys.argv[1]) if (len(sys.argv) > 1) else 5)
        nreplicas = (int(sys.argv[2]) if (len(sys.argv) > 2) else 4)
        nleaders = (int(sys.argv[3]) if (len(sys.argv) > 3) else 2)
        nclients = (int(sys.argv[4]) if (len(sys.argv) > 4) else 3)
        nops = (int(sys.argv[5]) if (len(sys.argv) > 5) else 3)
        repetitions = (int(sys.argv[6]) if (len(sys.argv) > 6) else 8)
        f = open((('paxoslogfile' + str(nacceptors)) + '.csv'), 'w')
        f.write('servers,runs,elapsed_time,cpu_time,cpu_memory \n')
        f.close()
        n = repetitions
        while (n > 0):
            stat_proc = self.new(Stat, ('orig', nacceptors, nreplicas, nleaders, nclients, nops, ((repetitions + 1) - n)), num=1)
            self._start(stat_proc)
            super()._label('_st_label_698', block=False)
            p = None

            def UniversalOpExpr_699():
                nonlocal p
                for p in stat_proc:
                    if (not PatternExpr_714.match_iter(self._Node_ReceivedEvent_0, _BoundPattern720_=p)):
                        return False
                return True
            _st_label_698 = 0
            while (_st_label_698 == 0):
                _st_label_698 += 1
                if UniversalOpExpr_699():
                    _st_label_698 += 1
                else:
                    super()._label('_st_label_698', block=True)
                    _st_label_698 -= 1
            else:
                if (_st_label_698 != 2):
                    continue
            if (_st_label_698 != 2):
                break
            n = (n - 1)
            self.output('done')
