import sys
import time
import psutil
import os
from logger import logger

import logging
import os.path

from sys import stderr
import random
import epaxos
import epaxos_optimized
import verify_correctness


# Statistics Class: Sets up the implementation and Calculates and logs performance metrics.
class Stat(process):
    def setup(algo, reqsNb, writes, conflicts, nreplicas, correct, optim, nops, runs):

        if correct > 0:
          self.correctness = True
        else:
          self.correctness = False

        if optim > 0:
          self.optimized = True
        else:
          self.optimized = False

        self.size_param = (reqsNb)
        self.karray = [0] * size_param
        self.rarray = [0] * size_param
        self.put = [False] * size_param
        for i in range(size_param):
          r = random.randint(0,nreplicas-1)
          self.rarray[i] = r

          r = random.randint(1,100)
          if r <= conflicts:
            self.karray[i] = 42
          else :
            self.karray[i] = int(43 + i)

          r = random.randint(1,100)
          if r <= writes:
            self.put[i] = 'PUT'
          else:
            self.put[i] = 'GET'

        if optimized:
          self.replicas = new(epaxos_optimized.Replica, num=nreplicas)
        else:
          self.replicas = new(epaxos.Replica, num=nreplicas)

        self.verifier = None
        if correctness:
          self.verifier = new(verify_correctness.correctnessverifier)

        self.readers = [0] * nreplicas
        self.writers = [0] * nreplicas
        self.replica_list = list(replicas)

    # gets the performance metrics before algorithm starts
    def start_stats():
        return(time.time(), psutil.cpu_times().user)

    # gets the performance metrics before algorithm ends
    def end_stats(start_time, start_time_c):
        e_time = time.time() - start_time
        c_time = psutil.cpu_times().user - start_time_c
        return('epaxos-optimized'+','+str(nreplicas)+ ',' + str(nops)+ ',' + str(runs) + ',' + str(e_time) + ',' + str(c_time))

#-----------------------------------------custom user code: start all processes :: start---------------------------------------
    def start_module(replicas, verifier, size_param, put, karray, replica_list, rarray, correctness):
        start(replicas)
        if verifier:
          start(verifier)

        for i in range(size_param):
          send(('request', (put[i], karray[i], i, self, i)), to=replica_list[rarray[i]])

          if correctness:
            time.sleep(0.01)
#-----------------------------------------custom user code: start all processes :: end-----------------------------------------
#-----------------------------------------custom user code: end all processes :: start-----------------------------------------
    def end_module(replicas, verifier, correctness, size_param):
        await((len(listof(x, received((_, x, _)))) + len(listof(x, received((_, x))))) == size_param)
        send(('shutdown',), to=replicas)
        if correctness:
          send(('shutdown',), to=verifier)
        return True
#----------------------------------------custom user code: end all processes :: end--------------------------------------------

    # logs statistics to file
    def write_to_file(stats):
        f = open('epaxos-logfile-NC-O.csv', "a")
        f.write(stats)
        f.close()

    # collect all the memory consumption statistics received from clients and servers
    def collect_memory_stats():
        # create a set of (p, m) values
        procmem = setof((p,m), received(('memory', p, m)))
        output('inside stub:-------------------------')
        output(procmem)
        procs = setof(p, received(('memory', p, _)))
        output(procs)
        total_memory_consumed = 0
        for p in list(procs):
            memset = setof(m, received(('memory', _p, m)))
            mem = 0
            for m in memset:
                mem += m
            # find the average memory consumed by thr process
            avg_mem = mem/len(memset)
            # add to the total memory consumed by current run
            total_memory_consumed += avg_mem
        return (','+ str(total_memory_consumed) + '\n')

    # sets up processes and calls internal methods
    def algorun(module):
#------------------------------custom user code: setup and start all the processes and clients:: start-----------------------
        for r in self.replicas:
          setup(r, (self.replicas, self.replicas, 0, self.verifier))

        if self.verifier:
          setup(self.verifier,(self.replicas,))
#------------------------------custom user code: setup and start all the processes and clients:: end-------------------------

        start_time, start_time_c = start_stats()

#------------------------------custom user code: pass parameters according to implementation:: start-------------------------
        start_module(self.replicas, self.verifier, self.size_param, self.put, self.karray, self.replica_list, self.rarray, self.correctness)

        # waits for all the clients to be done
        await(end_module(self.replicas, self.verifier, self.correctness, self.size_param))
#------------------------------custom user code: pass parameters according to implementation:: start--------------------------

        # collect end time statistics and write to log file
        stats = end_stats(start_time, start_time_c)

        # Collect the total memory consumed by clients and servers
        stats += collect_memory_stats()
        write_to_file(stats)

#------------------------------custom user code: Sending done to main() to inform it to end:: start---------------------------
        send(('done',), to= parent())
#------------------------------custom user code: Sending done to main() to inform it to end:: end-----------------------------

    def run():
        output('---------',algo,': run',runs,' started---------')
        module = import_da(algo)
        algorun(module)

def main():

    reqsNb = int(sys.argv[1]) if len(sys.argv) > 1 else 500
    # Percentage of writes or updates. Defaults to 100%
    writes = int(sys.argv[2]) if len(sys.argv) > 2 else 100
    # Percentage of conflicts. Defaults to 0
    conflicts = int(sys.argv[3]) if len(sys.argv) > 3 else 0
    # Replicas - utmost 5. defaults to 3
    nreplicas = int(sys.argv[4]) if len(sys.argv) > 4 else 3
    # Test correctness
    correct = int(sys.argv[5]) if len(sys.argv) > 5 else 0
    # Use optimized version
    optim = int(sys.argv[6]) if len(sys.argv) > 6 else 1
    runs = int(sys.argv[8]) if len(sys.argv) > 8 else 5
    nops = int(sys.argv[7]) if len(sys.argv) > 7 else 5

    # initial heading to the logfile added
    # if nops == 1:
    f = open('epaxos-logfile-NC-O.csv', 'w')
    f.write('program,servers,operations,runs,elapsed_time,cpu_time,cpu_memory(kB)\n')
    f.close()

    n = nops
    #--------------------custom user code: setting up and starting stats process for n repetitions :: start----------------------

    while n>0:
        stat_proc = new(Stat, ('epaxos', reqsNb, writes, conflicts, nreplicas, correct, optim, nops+1-n, runs+1-n), num= 1)
        start(stat_proc)
        # We are explicitly sending done to parent when clients are done
        await(each(p in stat_proc, has=received(('done',), from_=p)))
        n=n-1
        output('done')

#---------------------custom user code: setting up and starting stats process for n repetitions :: end------------------------
