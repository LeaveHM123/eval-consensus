'''
Sources : http://pmg.csail.mit.edu/papers/vr-to-bft.pdf (paper 1) vr-bft
          https://dspace.mit.edu/bitstream/handle/1721.1/71763/MIT-CSAIL-TR-2012-021.pdf?sequence=1 (paper 2) vr-revis
Command : python -m da vr-revised.da

'''
import sys
import random
import logging
import time
import json
import os
import itertools
import copy
import psutil
from sortedcontainers import SortedList
from collections import OrderedDict

NOPS = 10  # number of different operations
f = 1 #max number of replicas that can fail

class Replica(process):

    def setup(replicas):
        output('---------------Replica Setup--------------')
        self.view_number = 0 #the current view number according to this replica
        self.op_number = -1 #the operation number associated to a client request, generated by the replica
        self.log = [] #the list of operation ids
        self.status = "normal" #the replicas can be in the 'normal' state or 'recovering' state or they can be in the 'view change' state
        self.client_table = dict() #key = client id, value = [request number, result, operation number] Note The result is initialized to #
        self.commit_number = -1 #lastest committed message to be sent piggybacked along with the next prepare message.
        self.num_received_prepares = 1 #variable to track incoming "prepare" messages (for heartbeat)
        self.receiveRequests = 1 #variable to track incoming "request" messages from client (for heartbeat)
        self.heartbeat = 1 #if this variable is 1 the primary will send out heartbeat to the replicas, if the variable is 0 it won't
        self.x = -1 #nonce for this replica (this will be used if this replica goes to recovery state)
        self.proc = psutil.Process(os.getpid())

    def record_memory_consumed():
        send(('memory', self, proc.memory_info()[1]/1000), to= parent())
        output('parent id')
        output(parent())

    def run():
        output('---------------Replica run--------------')
        if self != replicas[view_number]:
           startTimer()
        await(received('done'))
        output('Replica terminating now!')

    def receive(msg=('recovery',x,), from_=recovering_replica):
        '''
        (From vr-revis, page 6, 4.3 Recovery, point 2)[LOC 80,92-93]:
        A replica j replies to a RECOVERY message only when its status is normal.
        In this case the replica sends a ⟨RECOVERYRESPONSE v, x, l, n, k, j⟩
        mes- sage to the recovering replica, where v is its view- number and x is
        the nonce in the RECOVERY mes- sage. If j is the primary of its view, l is
        its log, n is its op-number, and k is the commit-number; other- wise these
        values are nil.
        '''
        record_memory_consumed()
        if status == "normal":
            output("=============received message from recoving replica ================",replicas[2],x,self)
            send(('recoveryResponse',self.view_number,x,self.log,self.op_number,self.commit_number,replicas[self.view_number],self), to=recovering_replica)


    def receive(msg=('recoveryResponse',view_number,x,log,op_number,commit_number,primary,rep), from_=normal_replica):
        '''
        (From vr-revis, page 6, 4.3 Recovery, point 3)[LOC 80,92-93]:
        The recovering replica waits to receive at least f + 1 RECOVERYRESPONSE
        messages from different replicas, all containing the nonce it sent in its
        RE- COVERY message, including one from the primary of the latest view it
        learns of in these messages. Then it updates its state using the information
        from the primary, changes its status to normal, and the recovery protocol
        is complete.
        '''
        record_memory_consumed()
        nonce = self.x
        await(len(setof(rep, received(('recoveryResponse',_,_nonce,_,_,_,_,rep))))>=f+1 and some(received(('recoveryResponse',_,x,_,_,_,primary,rep)), has= x == self.x and primary == rep))
        self.view_number = view_number
        self.log = log
        self.op_number = op_number
        self.commit_number = commit_number
        self.status = "normal"
        output("=============the recovery replica has been updated and has joined the cluster ================",self)


    def receive(msg=('request',m,), from_=client):
        '''
        (From vr-revis, page 4, 4.1 Normal operation, point 2)[LOC 80,92-93]:
        When the primary receives the request, it compares the request-number in the
        request with the information in the client table. If the request-number s
        isn’t bigger than the information in the table it drops the request, but it
        will re-send the response if the re- quest is the most recent one from this
        client and it has already been executed.

        (From vr-revis, page 4, 4.1 Normal operation, point 3)[LOC 80-90]:
        The primary advances op-number, adds the request to the end of the
        log, and updates the information for this client in the client-table to
        contain the new request number, s. Then it sends a ⟨PREPARE v, m, n, k⟩
        message to the other replicas, where v is the current view-number, m is
        the message it received from the client, n is the op-number it assigned
        to the request, and k is the commit-number.

        (From vr-revis, page 4, 4.1 Normal operation, point 6)[LOC 79]
        Normally the primary informs backups about the commit when it sends the
        next PREPARE message; this is the purpose of the commit-number in the PREPARE
        message.

        '''
        record_memory_consumed()
        if self == replicas[view_number] and self.status =='normal':
            receiveRequests+=1
            output("==============received request from client =============", m[1])
            if status == "normal" and (m[1] not in client_table or client_table[m[1]][0] < m[2]):
                op_number = op_number+1
                if m[1] not in client_table:

                    client_table[m[1]] = [m[2],"#",op_number]
                else:
                    client_table[m[1]][0] = m[2]
                    client_table[m[1]][1] = "#"
                    client_table[m[1]][2] = op_number
                log.append(op_number)
                output('received request: ',m)
                send(('prepare', view_number, m, op_number, commit_number), to=replicas)
            elif m[1] in client_table and client_table[m[1]][0] == m[2] and client_table[m[1]][1] != "#":
                send(('reply', view_number, m[2], client_table[m[1]][1]), to= m[1])
            start_req_timer()


    def start_req_timer():
        if await(len(setof(m, received(('request', m,)))) == receiveRequests):
            output("============received request from client============")
        elif timeout(2):
            pass
            output("============SEND HEARTBEAT===========")
            send('heartbeat', to=replicas)

    def receive(msg=('prepare', v, m, n, k), from_=primary):
        '''
        (From vr-revis, page 4, 4.1 Normal operation, point 4)[LOC 104-117]
        Backups process PREPARE messages in order: a backup won’t accept a prepare
        with op-number n until it has entries for all earlier requests in its log.
        When a backup i receives a PREPARE message, it waits until it has entries
        in its log for all earlier re- quests (doing state transfer if necessary
        to get the missing information). Then it increments its op-number, adds the
        request to the end of its log, up- dates the client’s information in the
        client-table, and sends a ⟨PREPAREOK v, n, i⟩ message to the pri- mary to
        indicate that this operation and all earlier ones have prepared locally.

        (From vr-revis, page 4, 4.1 Normal operation, point 7)[LOC 104-117]
        When a backup learns of a commit, it waits un- til it has the request in its
        log (which may require state transfer) and until it has executed all earlier
        operations. Then it executes the operation by per- forming the up-call to the
        service code, increments its commit-number, updates the client’s entry in the
        client-table, but does not send the reply to the client.
        '''
        record_memory_consumed()

        if self == replicas[2] and self.status == 'normal':
            output("=============Turning this replica to recovering state to test ================",replicas[2])
            self.status = 'recovering'
            if self.status == "recovering":
                self.x = time.time() #x is the nonce
                send(('recovery', self.x), to= replicas)

        output("I received prepare from primary and Im :",self,m[1],n)
        if self!=primary and self.status == 'normal':
            num_received_prepares+=1
            await(each(o in range(n), has= some(received(('prepare',_,(_,m[1],_),_o,_)))))
            output("Log: ",log)
            op_number = op_number+1
            if m[1] not in client_table:

                client_table[m[1]] = [m[2],"#",op_number]
            else:
                client_table[m[1]][0] = m[2]
                client_table[m[1]][1] = "#"
                client_table[m[1]][2] = op_number
            log.append(op_number)
            send(('prepareok', view_number, op_number, m, self), to= primary)
            await(each(c in range(k), has= some(received(('prepare',_,(_,m[1],_),_,_c)))))
            commit_number = commit_number+1
            client_table[m[1]][1] = "answer = "+ str(m[2])
            output("###Latest Commit",commit_number)
            startTimer()

    def startTimer():
        '''
        (From vr-revis, page 5, 4.2 View Changes, point 1)[LOC 104-117]
        A replica i that notices the need for a view change advances its view-number,
        sets its status to view- change, and sends a ⟨STARTVIEWCHANGE v, i⟩ message
        to the all other replicas, where v iden- tifies the new view. A replica notices
        the need for a view change either based on its own timer, or because it receives
        a STARTVIEWCHANGE or DOVIEWCHANGE message for a view with a larger number than
        its own view-number.
        '''
        output("Length of set: ",len(setof(m, received(('prepare', _,m, _, _)))))
        output("Receive Prepares: ",num_received_prepares)
        if await(len(setof(m, received(('prepare',_,m,_,_)))) == num_received_prepares or heartbeat==1):
            heartbeat = 0
            output("============received a heartbeat or a prepare message from the primary==============")
        elif timeout(10):
            status = "view-change"
            view_number = (view_number + 1)%len(replicas)
            output("============REQUESTING VIEW CHANGE===========")
            send(('StartViewChange', view_number),to=replicas)
            send(('DoViewChange', view_number, log, commit_number, self),to=replicas[view_number])

    def receive(msg='heartbeat'):
        heartbeat = 1

    def receive(msg=('prepareok', v, n, m, rep), from_=replica):
        '''
        (From vr-revis, page 4, 4.1 Normal operation, point 5)[LOC 104-117]
        The primary waits for f PREPAREOK messages from different backups; at this
        point it considers the operation (and all earlier ones) to be commit- ted.
        Then, after it has executed all earlier operations (those assigned smaller
        op-numbers), the primary executes the operation by making an up-call
        to the service code, and increments its commit-number. Then it sends a
        ⟨REPLY v, s, x⟩ message to the client; here v is the view-number, s is the
        number the client provided in the request, and x is the result of the up-call.
        The primary also updates the client’s entry in the client-table to contain the result.
        '''
        record_memory_consumed()
        if self.status=='normal':
            if await(len(setof(rep, received(('prepareok', v, n, m, rep)))) >= f):
                client_table[m[1]][1] = "answer = "+ str(m[2])
                commit_number = n
                send(('reply', view_number, m[2], client_table[m[1]][1]), to= m[1])

    def receive(msg=('StartViewChange', v), from_=r):
        '''
        (From vr-revis, page 5, 4.2 View Changes, point 2)[LOC 104-117]
        WhenreplicaireceivesSTARTVIEWCHANGEmes- sages for its view-number from f other
        replicas, it sends a ⟨DOVIEWCHANGE v, l, v’, n, k, i⟩ message to the node that
        will be the primary in the new view. Here v is its view-number, l is its log,
        v′ is the view number of the latest view in which its status was normal, n is
        the op-number, and k is the commit- number.
        '''
        record_memory_consumed()
        if v > view_number and self.status=='normal':
            status = "view-change"
            output("=========== INSIDE StartViewChange method ================")
            send(('DoViewChange', v, log, view_number, op_number, commit_number, self),to=replicas[v])
            view_number = v


    def receive(msg=('DOVIEWCHANGE', v , log, previous_view, n, k, rep), from_=r):
        '''
        (From vr-revis, page 5, 4.2 View Changes, point 3)[LOC 104-117]
        When the new primary receives f + 1 DOVIEWCHANGE messages from different replicas
        ****(including itself)****, it sets its view-number to that in the messages and selects
        as the new log the one contained in the message with the largest v′; if several
        messages have the same v′ it selects the one among them with the largest n. It
        sets its op-number to that of the topmost entry in the new log, sets its commit-number
        to the largest such number it received in the DOVIEWCHANGE mes- sages, changes its
        status to normal, and informs the other replicas of the completion of the view
        change by sending ⟨STARTVIEW v, l, n, k⟩ messages to the other replicas, where
        l is the new log, n is the op-number, and k is the commit-number.

        (From vr-revis, page 6, 4.2 View Changes, point 4)[LOC 104-117]
        The new primary starts accepting client requests. It also executes (in order) any
        committed operations that it hadn’t executed previously, updates its client table,
        and sends the replies to the clients.
        '''
        record_memory_consumed()
        self.status = "view-change"
        output("=========== INSIDE DoViewChange method ================")
        if await(len(setof(rep, some(received(('DoViewChange',v,_,_,_,_,rep)), has= (replicas[v] == self))))>=f):
            output("============VIEW CHANGE HAPPENING ===========")
            vn = max(setof(previous_view, received(('DoViewChange',v , log, previous_view, n, k, rep)))or {0})
            new_op = max(setof(n, some(received(('DoViewChange',v , log, previous_view, n, k, rep)), has= previous_view == vn)) or {0})
            new_log = list(list(setof(tuple(log), some(received(('DoViewChange',v, log, previous_view, n, k, rep)), has= previous_view == vn and n == new_op)))[0])
            latest_commit_before_view_change = max(setof(k, some(received(('DoViewChange',v , log, previous_view, n, k, rep)))) or {0})
            output ("the selected new log :",new_log)
            output ("the latest commit :",latest_commit_before_view_change)
            view_number = v
            status = "normal"
            log = new_log
            commit_number = latest_commit_before_view_change
            op_number = new_op
            for commit in range(latest_commit_before_view_change+1):
                for key in client_table.keys():
                    if client_table[key][2] == commit:
                        client_table[key][1] = "answer = "+ str(client_table[key][0])
                        output("========Sending the new view to client :", v)
                        send(('reply', view_number, commit_number, client_table[key][1]), to= key)
            output("==================sending startview to replicas==========",replicas)
            send(('StartView', view_number, log, op_number, commit_number, self),to=replicas)

    def receive(msg=('StartView', v, l, n, k, rep), from_=primary):
        '''
        (From vr-revis, page 6, 4.2 View Changes, point 5)[LOC 104-117]
        When other replicas receive the STARTVIEW mes- sage, they replace their log
        with the one in the mes- sage, set their op-number to that of the latest entry
        in the log, set their view-number to the view num- ber in the message, change
        their status to normal, and update the information in their client-table.
        Then they execute all op- erations known to be committed that they haven’t
        executed previously, advance their commit-number, and update the information
        in their client-table.
        '''
        record_memory_consumed()
        self.status = "normal"
        self.view_number = v
        output("=================new view===========",v)
        self.op_number = n
        self.log = l
        self.commit_number = k
        for commit in range(commit_number+1):
            for key in client_table.keys():
                if self.client_table[key][2] == commit:
                    self.client_table[key][1] = "answer = "+ str(client_table[key][0])


class Client(process):

    def setup(replicas, nops:int):
        output('---------------Client Setup--------------')
        self.view_number = 0 #the view number known to the client
        self.s = 0           # id associated with the request that client sends to the primary
        self.results = dict()  # key = command id, value = result of the command
        self.proc = psutil.Process(os.getpid())

    def record_memory_consumed():
        send(('memory', self, proc.memory_info()[1]/1000), to= parent())
        #output('m-m-m-m-m-m-m-m-m-m-m-m-m-m-m-m-'+proc.memory_info())

    def run():
        '''
        (From vr-revis, page 4, 4.1 Normal operation, point 1)[LOC 216]:
        The client sends a ⟨REQUEST op, c, s⟩ message to the primary, where
        op is the operation (with its arguments) the client wants to run,
        c is the client-id, and s is the request-number assigned to the request.

        (From vr-revis, page 4, 4.1 Normal operation, below point 7)[LOC 216]:
        If a client doesn’t receive a timely response to a re- quest, it
        re-sends the request to all replicas. This way if the group has
        moved to a later view, its message will reach the new primary. Backups
        ignore client requests; only the primary processes them.
        '''
        output("---------------Client run-------------------")
        for i in range(nops):
            output("###run",i)
            #time.sleep(20)
            output("==============Sending request to primary :", view_number)
            send(('request',(random.randint(0, NOPS-1), self, s)),to=replicas[view_number])
            if await(s in results):
                output('For request number ->', s, results[s])
                s += 1
            elif timeout(10):
                output('Client Timed Out: Resending request to all replicas')
                send(('request',(random.randint(0, NOPS-1), self, s)),to=replicas)
                if await(s in results):
                    output('For request number ->', s, results[s])
                    s += 1
                elif timeout(10):
                    output('Im Client, Seems like the system has gone down, no replica is replying to me. Client terminating now!')
                    output('Client terminating now!')
                    send('done',to=replicas)
                    break

        if len(results) == nops:
            output('All the operations are done! Client terminating now!')
            send('done',to=replicas)

    def receive(msg= ('reply', v, cid, result)):
        record_memory_consumed()
        output('response', cid, result)
        if view_number < v:
            view_number = v
        output("======I'm client and I think the view is :", view_number)
        if cid not in results:
            results[cid] = result
        elif results[cid] != result:
            output('different result', cid, result, 'than', results[cid])


def main():
    output("-------------------Entering main-----------------")
    NumReplicas = (2*f)+1 #number of replicas
    NumClients = 1 #number of clients
    nops = 5 #number of operations

    replicas = list(new(Replica,num=NumReplicas))
    clients = new(Client, (replicas, nops,), num=NumClients)
    setup(replicas,(replicas,))


    start(replicas)
    start(clients)

    # end(clients)
    # end(replicas
