# -*- generated by 1.0.12 -*-
import da
PatternExpr_478 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_498 = da.pat.TuplePattern([da.pat.ConstantPattern('request'), da.pat.FreePattern('p'), da.pat.FreePattern('clk')])
PatternExpr_535 = da.pat.TuplePattern([da.pat.ConstantPattern('decision'), da.pat.FreePattern('s'), da.pat.FreePattern('p'), da.pat.FreePattern('cmdr'), da.pat.FreePattern('clk')])
PatternExpr_483 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_679 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_699 = da.pat.FreePattern('m')
PatternExpr_717 = da.pat.TuplePattern([da.pat.ConstantPattern('p1a'), da.pat.FreePattern(None), da.pat.FreePattern('b'), da.pat.FreePattern(None)])
PatternExpr_743 = da.pat.TuplePattern([da.pat.ConstantPattern('p2a'), da.pat.FreePattern(None), da.pat.FreePattern('b'), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_774 = da.pat.TuplePattern([da.pat.ConstantPattern('p1a'), da.pat.FreePattern('leader_scout'), da.pat.FreePattern('b'), da.pat.FreePattern('clk')])
PatternExpr_837 = da.pat.TuplePattern([da.pat.ConstantPattern('p2a'), da.pat.FreePattern('leader_commander'), da.pat.FreePattern('b'), da.pat.FreePattern('s'), da.pat.FreePattern('p'), da.pat.FreePattern('clk')])
PatternExpr_684 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_1016 = da.pat.TuplePattern([da.pat.ConstantPattern('p2b'), da.pat.FreePattern('a'), da.pat.BoundPattern('_BoundPattern1021_'), da.pat.FreePattern(None)])
PatternExpr_1072 = da.pat.TuplePattern([da.pat.ConstantPattern('p2b'), da.pat.FreePattern(None), da.pat.FreePattern('b1'), da.pat.FreePattern(None)])
PatternExpr_1130 = da.pat.TuplePattern([da.pat.ConstantPattern('p2b'), da.pat.FreePattern('p'), da.pat.FreePattern(None), da.pat.FreePattern('clk')])
PatternExpr_1260 = da.pat.TuplePattern([da.pat.ConstantPattern('p1b'), da.pat.FreePattern('a'), da.pat.BoundPattern('_BoundPattern1265_'), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_1294 = da.pat.TuplePattern([da.pat.ConstantPattern('p1b'), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1298_'), da.pat.FreePattern('r'), da.pat.FreePattern(None)])
PatternExpr_1352 = da.pat.TuplePattern([da.pat.ConstantPattern('p1b'), da.pat.FreePattern('a'), da.pat.FreePattern('b1'), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_1411 = da.pat.TuplePattern([da.pat.ConstantPattern('p1b'), da.pat.FreePattern('p'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern('clk')])
PatternExpr_1555 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_1575 = da.pat.TuplePattern([da.pat.ConstantPattern('propose'), da.pat.FreePattern('s'), da.pat.FreePattern('p'), da.pat.FreePattern('rpl'), da.pat.FreePattern('clk')])
PatternExpr_1665 = da.pat.TuplePattern([da.pat.ConstantPattern('adopted'), da.pat.FreePattern('ballot_num'), da.pat.FreePattern('pvals'), da.pat.FreePattern('scout'), da.pat.FreePattern('clk')])
PatternExpr_1757 = da.pat.TuplePattern([da.pat.ConstantPattern('preempted'), da.pat.TuplePattern([da.pat.FreePattern('r1'), da.pat.FreePattern('leader1')]), da.pat.FreePattern('proc'), da.pat.FreePattern('clk')])
PatternExpr_1560 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_2032 = da.pat.TuplePattern([da.pat.ConstantPattern('response'), da.pat.FreePattern('cid'), da.pat.FreePattern('result'), da.pat.FreePattern('rpl'), da.pat.FreePattern('clk')])
PatternExpr_2256 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_2261 = da.pat.BoundPattern('_BoundPattern2262_')
PatternExpr_2263 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern2269_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
_config_object = {}
import sys
import time
import random
import psutil
import os
from logger import logger
log_file = 'vrpaxos.log'
NOPS = 10

def operation(i):
    return (lambda state: ((state + [i]), ['result', i, 'on', state]))
operations = {i: operation(i) for i in range(NOPS)}

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_478, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_498, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_497]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_535, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_534])])

    def setup(self, leaders, initial_state, **rest_2284):
        super().setup(leaders=leaders, initial_state=initial_state, **rest_2284)
        self._state.leaders = leaders
        self._state.initial_state = initial_state
        self._state.state = self._state.initial_state
        self._state.slot_num = 1
        self._state.proposals = set()
        self._state.decisions = set()
        self._state.proc = psutil.Process(os.getpid())
        self._state.clock = 1
        logger.info('{0} {{"{0}":{1}}} {0} Initialization complete'.format(self._id, self._state.clock))

    def run(self):
        self.debug('### start')
        super()._label('_st_label_475', block=False)
        _st_label_475 = 0
        while (_st_label_475 == 0):
            _st_label_475 += 1
            if PatternExpr_483.match_iter(self._ReplicaReceivedEvent_0, SELF_ID=self._id):
                _st_label_475 += 1
            else:
                super()._label('_st_label_475', block=True)
                _st_label_475 -= 1
        self.output('terminating')

    def record_memory_consumed(self):
        self.send(('memory', self._id, (self._state.proc.memory_info()[1] / 1000)), to=self.parent())

    def propose(self, p):

        def ExistentialOpExpr_302():
            for (_, _BoundPattern306_) in self._state.decisions:
                if (_BoundPattern306_ == p):
                    if True:
                        return True
            return False
        if (not ExistentialOpExpr_302()):
            maxs = max(({s for (s, _) in (self._state.proposals | self._state.decisions)} or {0}))

            def ExistentialOpExpr_344(s):
                for (_BoundPattern347_, _) in (self._state.proposals | self._state.decisions):
                    if (_BoundPattern347_ == s):
                        if True:
                            return True
                return False
            s1 = min({s for s in range(1, ((maxs + 1) + 1)) if (not ExistentialOpExpr_344(s=s))})
            self._state.proposals.add((s1, p))
            self._state.clock += 1
            logger.info('{0} {{"{0}":{1}}} {0} sending proposal to leaders'.format(self._id, self._state.clock))
            self.send(('propose', s1, p, self._id, self._state.clock), to=self._state.leaders)
            self.record_memory_consumed()

    def perform(self, p):
        self.debug('### perform', p)
        (client, cid, op) = p
        s = None

        def ExistentialOpExpr_405():
            nonlocal s
            for (s, _BoundPattern410_) in self._state.decisions:
                if (_BoundPattern410_ == p):
                    if (s < self._state.slot_num):
                        return True
            return False
        if ExistentialOpExpr_405():
            self._state.slot_num += 1
        else:
            self.debug('===', self._state.state, op)
            (next, result) = operations[op](self._state.state)
            self.debug('===', next, result)
            self._state.state = next
            self._state.slot_num += 1
            self._state.clock += 1
            logger.info('{0} {{"{0}":{1}}} {0} sending decision to {2}'.format(self._id, self._state.clock, client))
            self.send(('response', cid, result, self._id, self._state.clock), to=client)
        self.record_memory_consumed()

    def _Replica_handler_497(self, p, clk):
        self.debug('### request', p)
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received request from client {2}'.format(self._id, self._state.clock, p[0], clk))
        self.propose(p)
    _Replica_handler_497._labels = None
    _Replica_handler_497._notlabels = None

    def _Replica_handler_534(self, s, p, cmdr, clk):
        self.debug('### decision', s, p)
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received decision from commander {2}'.format(self._id, self._state.clock, cmdr, clk))
        self._state.decisions.add((s, p))
        p1 = None

        def ExistentialOpExpr_577():
            nonlocal p1
            for (_BoundPattern580_, p1) in self._state.decisions:
                if (_BoundPattern580_ == self._state.slot_num):
                    if True:
                        return True
            return False
        while ExistentialOpExpr_577():
            p2 = None

            def ExistentialOpExpr_587():
                nonlocal p2
                for (_BoundPattern590_, p2) in self._state.proposals:
                    if (_BoundPattern590_ == self._state.slot_num):
                        if (not (p2 == p1)):
                            return True
                return False
            if ExistentialOpExpr_587():
                self.propose(p2)
            self.perform(p1)
    _Replica_handler_534._labels = None
    _Replica_handler_534._notlabels = None

class Acceptor(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._AcceptorReceivedEvent_0 = []
        self._AcceptorReceivedEvent_2 = []
        self._AcceptorReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_679, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_1', PatternExpr_699, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_698]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_2', PatternExpr_717, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_3', PatternExpr_743, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_4', PatternExpr_774, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_773]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_5', PatternExpr_837, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_836])])

    def setup(self, **rest_2284):
        super().setup(**rest_2284)
        self._state.ballot_num = None
        self._state.accepted = set()
        self._state.proc = psutil.Process(os.getpid())
        self._state.clock = 1
        logger.info('{0} {{"{0}":{1}}} {0} Initialization complete'.format(self._id, self._state.clock))

    def run(self):
        self.debug('### start')
        super()._label('_st_label_676', block=False)
        _st_label_676 = 0
        while (_st_label_676 == 0):
            _st_label_676 += 1
            if PatternExpr_684.match_iter(self._AcceptorReceivedEvent_0, SELF_ID=self._id):
                _st_label_676 += 1
            else:
                super()._label('_st_label_676', block=True)
                _st_label_676 -= 1
        self.output('terminating')

    def record_memory_consumed(self):
        self.send(('memory', self._id, (self._state.proc.memory_info()[1] / 1000)), to=self.parent())

    def _Acceptor_handler_698(self, m):
        BOTTOM = ((- 1), (- 1))
        self._state.ballot_num = max((({b for (_, _, (_ConstantPattern734_, _, b, _)) in self._AcceptorReceivedEvent_2 if (_ConstantPattern734_ == 'p1a')} | {b for (_, _, (_ConstantPattern761_, _, b, _, _)) in self._AcceptorReceivedEvent_3 if (_ConstantPattern761_ == 'p2a')}) or {BOTTOM}))
    _Acceptor_handler_698._labels = None
    _Acceptor_handler_698._notlabels = None

    def _Acceptor_handler_773(self, leader_scout, b, clk):
        self.debug('### p1a', leader_scout, b)
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received P1A message from scout {2}'.format(self._id, self._state.clock, leader_scout, clk))
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}}} {0} Sending P1B message to scout {2}'.format(self._id, self._state.clock, leader_scout))
        self.send(('p1b', self._id, self._state.ballot_num, self._state.accepted, self._state.clock), to=leader_scout)
        self.record_memory_consumed()
    _Acceptor_handler_773._labels = None
    _Acceptor_handler_773._notlabels = None

    def _Acceptor_handler_836(self, leader_commander, b, s, p, clk):
        self.debug('### p2a', leader_commander, b, s, p, clk)
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received P2A message from commander {2}'.format(self._id, self._state.clock, leader_commander, clk))
        if (b == self._state.ballot_num):
            self._state.accepted.add((b, s, p))
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}}} {0} Sending P2B message to commander {2}'.format(self._id, self._state.clock, leader_commander))
        self.send(('p2b', self._id, self._state.ballot_num, self._state.clock), to=leader_commander)
        self.record_memory_consumed()
    _Acceptor_handler_836._labels = None
    _Acceptor_handler_836._notlabels = None

class Commander(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._CommanderReceivedEvent_0 = []
        self._CommanderReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_CommanderReceivedEvent_0', PatternExpr_1016, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CommanderReceivedEvent_1', PatternExpr_1072, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CommanderReceivedEvent_2', PatternExpr_1130, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Commander_handler_1129])])

    def setup(self, leader, acceptors, replicas, b, s, p, clk, **rest_2284):
        super().setup(leader=leader, acceptors=acceptors, replicas=replicas, b=b, s=s, p=p, clk=clk, **rest_2284)
        self._state.leader = leader
        self._state.acceptors = acceptors
        self._state.replicas = replicas
        self._state.b = b
        self._state.s = s
        self._state.p = p
        self._state.clk = clk
        self._state.proc = psutil.Process(os.getpid())
        self._state.clock = 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Initiated by leader {2}'.format(self._id, self._state.clock, self._state.leader, self._state.clk))

    def run(self):
        self.debug('### start')
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}}} {0} Sending P2A message to acceptors'.format(self._id, self._state.clock))
        self.send(('p2a', self._id, self._state.b, self._state.s, self._state.p, self._state.clock), to=self._state.acceptors)
        super()._label('_st_label_1011', block=False)
        b1 = None

        def ExistentialOpExpr_1070():
            nonlocal b1
            for (_, _, (_ConstantPattern1089_, _, b1, _)) in self._CommanderReceivedEvent_1:
                if (_ConstantPattern1089_ == 'p2b'):
                    if (not (b1 == self._state.b)):
                        return True
            return False
        _st_label_1011 = 0
        while (_st_label_1011 == 0):
            _st_label_1011 += 1
            if (len({a for (_, _, (_ConstantPattern1033_, a, _BoundPattern1036_, _)) in self._CommanderReceivedEvent_0 if (_ConstantPattern1033_ == 'p2b') if (_BoundPattern1036_ == self._state.b)}) > (len(self._state.acceptors) / 2)):
                self._state.clock += 1
                logger.info('{0} {{"{0}":{1}}} {0} Sending decision to replicas'.format(self._id, self._state.clock))
                self.send(('decision', self._state.s, self._state.p, self._id, self._state.clock), to=self._state.replicas)
                _st_label_1011 += 1
            elif ExistentialOpExpr_1070():
                self._state.clock += 1
                logger.info('{0} {{"{0}":{1}}} {0} Sending preempted message to leader {2}'.format(self._id, self._state.clock, self._state.leader))
                self.send(('preempted', b1, self._id, self._state.clock), to=self._state.leader)
                _st_label_1011 += 1
            else:
                super()._label('_st_label_1011', block=True)
                _st_label_1011 -= 1
        self.record_memory_consumed()

    def record_memory_consumed(self):
        self.send(('memory', self._id, (self._state.proc.memory_info()[1] / 1000)), to=self.parent())

    def _Commander_handler_1129(self, p, clk):
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received P2B message from acceptor {2}'.format(self._id, self._state.clock, p, clk))
    _Commander_handler_1129._labels = None
    _Commander_handler_1129._notlabels = None

class Scout(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ScoutReceivedEvent_0 = []
        self._ScoutReceivedEvent_1 = []
        self._ScoutReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ScoutReceivedEvent_0', PatternExpr_1260, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ScoutReceivedEvent_1', PatternExpr_1294, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ScoutReceivedEvent_2', PatternExpr_1352, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ScoutReceivedEvent_3', PatternExpr_1411, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Scout_handler_1410])])

    def setup(self, leader, acceptors, b, clk, **rest_2284):
        super().setup(leader=leader, acceptors=acceptors, b=b, clk=clk, **rest_2284)
        self._state.leader = leader
        self._state.acceptors = acceptors
        self._state.b = b
        self._state.clk = clk
        self._state.pvalues = set()
        self._state.proc = psutil.Process(os.getpid())
        self._state.clock = 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Initiated by leader {2}'.format(self._id, self._state.clock, self._state.leader, self._state.clk))

    def run(self):
        self.debug('### start')
        time.sleep(random.random())
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}}} {0} Sending P1A message to acceptors'.format(self._id, self._state.clock))
        self.send(('p1a', self._id, self._state.b, self._state.clock), to=self._state.acceptors)
        super()._label('_st_label_1255', block=False)
        b1 = a = None

        def ExistentialOpExpr_1350():
            nonlocal b1, a
            for (_, _, (_ConstantPattern1371_, a, b1, _, _)) in self._ScoutReceivedEvent_2:
                if (_ConstantPattern1371_ == 'p1b'):
                    if (not (b1 == self._state.b)):
                        return True
            return False
        _st_label_1255 = 0
        while (_st_label_1255 == 0):
            _st_label_1255 += 1
            if (len({a for (_, _, (_ConstantPattern1278_, a, _BoundPattern1281_, _, _)) in self._ScoutReceivedEvent_0 if (_ConstantPattern1278_ == 'p1b') if (_BoundPattern1281_ == self._state.b)}) > (len(self._state.acceptors) / 2)):
                self._state.pvalues = {v for (_, _, (_ConstantPattern1312_, _, _BoundPattern1315_, r, _)) in self._ScoutReceivedEvent_1 if (_ConstantPattern1312_ == 'p1b') if (_BoundPattern1315_ == self._state.b) for v in r}
                self._state.clock += 1
                logger.info('{0} {{"{0}":{1}}} {0} Sending adopted message to leader {2}'.format(self._id, self._state.clock, self._state.leader))
                self.send(('adopted', self._state.b, self._state.pvalues, self._id, self._state.clock), to=self._state.leader)
                _st_label_1255 += 1
            elif ExistentialOpExpr_1350():
                self._state.clock += 1
                logger.info('{0} {{"{0}":{1}}} {0} Sending preempted message to leader {2}'.format(self._id, self._state.clock, self._state.leader))
                self.send(('preempted', b1, self._id, self._state.clock), to=self._state.leader)
                _st_label_1255 += 1
            else:
                super()._label('_st_label_1255', block=True)
                _st_label_1255 -= 1
        self.record_memory_consumed()

    def record_memory_consumed(self):
        self.send(('memory', self._id, (self._state.proc.memory_info()[1] / 1000)), to=self.parent())

    def _Scout_handler_1410(self, p, clk):
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received P1B message from acceptor {2}'.format(self._id, self._state.clock, p, clk))
    _Scout_handler_1410._labels = None
    _Scout_handler_1410._notlabels = None

class Leader(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._LeaderReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LeaderReceivedEvent_0', PatternExpr_1555, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LeaderReceivedEvent_1', PatternExpr_1575, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Leader_handler_1574]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LeaderReceivedEvent_2', PatternExpr_1665, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Leader_handler_1664]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LeaderReceivedEvent_3', PatternExpr_1757, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Leader_handler_1756])])

    def setup(self, acceptors, replicas, **rest_2284):
        super().setup(acceptors=acceptors, replicas=replicas, **rest_2284)
        self._state.acceptors = acceptors
        self._state.replicas = replicas
        self._state.ballot_num = (0, self._id)
        self._state.active = False
        self._state.proposals = set()
        self._state.proc = psutil.Process(os.getpid())
        self._state.clock = 1
        logger.info('{0} {{"{0}":{1}}} {0} Initialization complete'.format(self._id, self._state.clock))

    def run(self):
        self.debug('### start')
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}}} {0} Initializing Scout'.format(self._id, self._state.clock))
        sub = self.new(Scout, (self._id, self._state.acceptors, self._state.ballot_num, self._state.clock), method='thread', daemon=True)
        self._start(sub)
        super()._label('_st_label_1552', block=False)
        _st_label_1552 = 0
        while (_st_label_1552 == 0):
            _st_label_1552 += 1
            if PatternExpr_1560.match_iter(self._LeaderReceivedEvent_0, SELF_ID=self._id):
                _st_label_1552 += 1
            else:
                super()._label('_st_label_1552', block=True)
                _st_label_1552 -= 1
        self.output('terminating')

    def record_memory_consumed(self):
        self.send(('memory', self._id, (self._state.proc.memory_info()[1] / 1000)), to=self.parent())

    def circle_plus(self, x, y):

        def ExistentialOpExpr_1837(s):
            for (_BoundPattern1840_, _) in y:
                if (_BoundPattern1840_ == s):
                    if True:
                        return True
            return False
        return (y | {(s, p) for (s, p) in x if (not ExistentialOpExpr_1837(s=s))})

    def pmax(self, pvals):

        def UniversalOpExpr_1863(s, b):
            for (b1, _BoundPattern1868_, _) in pvals:
                if (_BoundPattern1868_ == s):
                    if (not (b1 <= b)):
                        return False
            return True
        return {(s, p) for (b, s, p) in pvals if UniversalOpExpr_1863(s=s, b=b)}

    def _Leader_handler_1574(self, s, p, rpl, clk):
        self.debug('### propose', s, p)
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received propose request from replica {2}'.format(self._id, self._state.clock, rpl, clk))

        def ExistentialOpExpr_1609():
            for (_BoundPattern1612_, _) in self._state.proposals:
                if (_BoundPattern1612_ == s):
                    if True:
                        return True
            return False
        if (not ExistentialOpExpr_1609()):
            self._state.proposals.add((s, p))
            if self._state.active:
                self._state.clock += 1
                logger.info('{0} {{"{0}":{1}}} {0} Initializing Commander'.format(self._id, self._state.clock))
                sub = self.new(Commander, (self._id, self._state.acceptors, self._state.replicas, self._state.ballot_num, s, p, self._state.clock), method='thread', daemon=True)
                self._start(sub)
                self.record_memory_consumed()
    _Leader_handler_1574._labels = None
    _Leader_handler_1574._notlabels = None

    def _Leader_handler_1664(self, ballot_num, pvals, scout, clk):
        self.debug('### adopted', ballot_num, pvals)
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received adopted message from scout {2}'.format(self._id, self._state.clock, scout, clk))
        self._state.proposals = self.circle_plus(self._state.proposals, self.pmax(pvals))
        for (s, p) in self._state.proposals:
            self._state.clock += 1
            logger.info('{0} {{"{0}":{1}}} {0} Initializing Commander'.format(self._id, self._state.clock))
            sub = self.new(Commander, (self._id, self._state.acceptors, self._state.replicas, ballot_num, s, p, self._state.clock), method='thread', daemon=True)
            self._start(sub)
            self.record_memory_consumed()
        self._state.active = True
    _Leader_handler_1664._labels = None
    _Leader_handler_1664._notlabels = None

    def _Leader_handler_1756(self, r1, leader1, proc, clk):
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received preempted message from {2}'.format(self._id, self._state.clock, proc, clk))
        if ((r1, leader1) > self._state.ballot_num):
            self._state.active = False
            self._state.ballot_num = ((r1 + 1), self._id)
            sub = self.new(Scout, (self._id, self._state.acceptors, self._state.ballot_num), method='thread', daemon=True)
            self._start(sub)
            self.record_memory_consumed()
    _Leader_handler_1756._labels = None
    _Leader_handler_1756._notlabels = None

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_2032, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_2031])])

    def setup(self, replicas, nops, **rest_2284):
        super().setup(replicas=replicas, nops=nops, **rest_2284)
        self._state.replicas = replicas
        self._state.nops = nops
        self._state.cid = 0
        self._state.results = dict()
        self._state.count = dict()
        self._state.proc = psutil.Process(os.getpid())
        self._state.clock = 1
        logger.info('{0} {{"{0}":{1}}} {0} Initialization complete'.format(self._id, self._state.clock))

    def run(self):
        for i in range(self._state.nops):
            self._state.clock += 1
            logger.info('{0} {{"{0}":{1}}} {0} Sending request {2} to all replicas.'.format(self._id, self._state.clock, self._state.cid))
            self.send(('request', (self._id, self._state.cid, random.randint(0, (NOPS - 1))), self._state.clock), to=self._state.replicas)
            super()._label('_st_label_1991', block=False)
            _st_label_1991 = 0
            while (_st_label_1991 == 0):
                _st_label_1991 += 1
                if (self._state.cid in self._state.results):
                    _st_label_1991 += 1
                else:
                    super()._label('_st_label_1991', block=True)
                    _st_label_1991 -= 1
            else:
                if (_st_label_1991 != 2):
                    continue
            if (_st_label_1991 != 2):
                break
            self.output('received result', self._state.cid, self._state.results[self._state.cid])
            self._state.cid += 1
            self.record_memory_consumed()
        super()._label('_st_label_2008', block=False)
        cid = None

        def UniversalOpExpr_2009():
            nonlocal cid
            for self._state.cid in range(self._state.nops):
                if (not (self._state.count[self._state.cid] == len(self._state.replicas))):
                    return False
            return True
        _st_label_2008 = 0
        while (_st_label_2008 == 0):
            _st_label_2008 += 1
            if UniversalOpExpr_2009():
                _st_label_2008 += 1
            else:
                super()._label('_st_label_2008', block=True)
                _st_label_2008 -= 1
        self.output('terminating')
        self.send(('done',), to=self.parent())

    def record_memory_consumed(self):
        self.send(('memory', self._id, (self._state.proc.memory_info()[1] / 1000)), to=self.parent())

    def _Client_handler_2031(self, cid, result, rpl, clk):
        self.debug('### response', cid, result)
        self._state.clock += 1
        logger.info('{0} {{"{0}":{1}, "{2}":{3}}} {0} Received response from replica {2}'.format(self._id, self._state.clock, rpl, clk))
        if (not (cid in self._state.results)):
            self._state.results[cid] = result
        elif (not (self._state.results[cid] == result)):
            self.error('different result', cid, result, 'than', self._state.results[cid])
        self._state.count[cid] = (1 if (not (cid in self._state.count)) else (self._state.count[cid] + 1))
        self.record_memory_consumed()
    _Client_handler_2031._labels = None
    _Client_handler_2031._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_2256, sources=[PatternExpr_2261], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nacceptors = (int(sys.argv[1]) if (len(sys.argv) > 1) else 5)
        nreplicas = (int(sys.argv[2]) if (len(sys.argv) > 2) else 4)
        nleaders = (int(sys.argv[3]) if (len(sys.argv) > 3) else 2)
        nclients = (int(sys.argv[4]) if (len(sys.argv) > 4) else 3)
        nops = (int(sys.argv[5]) if (len(sys.argv) > 5) else 3)
        acceptors = self.new(Acceptor, (), num=nacceptors)
        replicas = self.new(Replica, num=nreplicas)
        leaders = self.new(Leader, (acceptors, replicas), num=nleaders)
        initial_state = []
        self._setup(replicas, (leaders, initial_state))
        clients = self.new(Client, (replicas, nops), num=nclients)
        self._start(acceptors)
        self._start((replicas | leaders))
        self._start(clients)
        super()._label('_st_label_2247', block=False)
        c = None

        def UniversalOpExpr_2248():
            nonlocal c
            for c in clients:
                if (not PatternExpr_2263.match_iter(self._Node_ReceivedEvent_0, _BoundPattern2269_=c)):
                    return False
            return True
        _st_label_2247 = 0
        while (_st_label_2247 == 0):
            _st_label_2247 += 1
            if UniversalOpExpr_2248():
                _st_label_2247 += 1
            else:
                super()._label('_st_label_2247', block=True)
                _st_label_2247 -= 1
        self.output('All clients done.')
        self.send(('done',), to=((acceptors | replicas) | leaders))
